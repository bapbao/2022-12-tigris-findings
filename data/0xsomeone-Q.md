# Tigris Trade Quality Assurance Review

This document constitutes a Q&A review of the Tigris codebase. It has attempted to be as thorough as possible, however, the `Trading` and `TradingExtension` contracts have not been adequately covered as time did not permit. 

## High-Level Comments

The codebase lacks re-entrancy controls across its modules whilst it presumably interacts with arbitrary "Tigris" assets. This led to two major severity vulnerabilities being identified during our review of the codebase. Additionally, the code suffers from a non-comformant coding style that deviates from the [official Solidity style guidelines](https://docs.soliditylang.org/en/v0.8.17/style-guide.html), rendering the codebase difficult to traverse and assimilate. 

As a last note, the `pragma` statement of `ExcessivelySafeCall` (an external dependency from LayerZero copied to the project) should be locked to a static `pragma` version to avoid the major / breaking changes that occur during a minor semver change in Solidity.

## MetaContext.sol

The contract is meant to conform to the [EIP-2771](https://eips.ethereum.org/EIPS/eip-2771) standard ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/MetaContext.sol#L13)), however, it does not denote this nor does it define a clear `interface` for it ensuring updates to it will continue conforming to the standard. It is highly advisable to introduce such an `interface` and explicitly label it as `EIP-2771` to ensure external integrators of your project are aware of this conformity.

## TradingLibrary.sol 

The contract contains multiple top-level declarations ([`IPrice`](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L7), [`TradingLibrary`](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L21)) which we advise be split into dedicated files for a more robust code structure.

Multiple unsafe casting operations from the `uint256` data type to the `int256` data type can be observed ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L40), [#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L42), [#3](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L44), [#4](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L46), [#5](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L64), [#6](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L66)) which, contrary to popular belief, will be performed "unsafely" even in `pragma` versions `0.8.X` given that casting operations are excluded from arithmetic safety. We advise them to be performed safely by using a library such as [`SafeCast` by OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/utils/math/SafeCast.sol). These unsafe operations were not assessed for severity due to the complexity of the project and time allocated, however, they may lead to minor-to-major severity vulnerabilities arising if properly assessed.

The `PairsContract` contract does not sanitize a maximum leverage value while the `pnl` function (which performs explicit `unchecked` arithmetics) performs a multiplication of `_margin` with `_leverage`, rendering it prone to overflows. We advise the code to use `unchecked` arithmetics solely wherever they are guaranteed to be performed safely and the "blanket" `unchecked` statement to be omitted from the `pnl` function.

The conditionals of `pnl` ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L39), [#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L41), [#3](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L43), [#4](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L45)) are meant to indicate a "zero-sum" game, however, the opposite ends do not use the proper conditionals (i.e. the `price` condition of #2 should match #3 with only `_direction` inverted). We advise this to be done so to more clearly illustrate the opposite ends of the calculation.

The calculation `x * 1e18 / y` is performed repeatedly in the codebase ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L38), [#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L40), [#3](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L42), [#4](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L44), [#5](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L64), [#6](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L66)) and can be bundled in a single utility function that is `internal` / `private`.

The Chainlink integration component performs an unsafe casting operation of the yielded `int256` to `uint256` without evaluating if it is positive ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L115)). While the case of a negative price reported by Chainlink is abysmal, we still advise the conditional to instead be changed to a greater-than `0` rather than not equal to `0` one.

The codebase contains a discrepancy between its documentation and the actual implementation. In detail, the [last paragraph of the referenced documentation](https://docs.tigris.trade/protocol/oracle#what-is-a-distributed-signature-based-oracle-network) indicates that a price is declined when it **has more than a 2% price difference from Chainlink** whilst the codebase prohibits the **equality case with 2%, rendering the statement incorrect as it should state "more than or equal to** ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L117), [#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L118)). This constitutes a deviation from the project's specification albeit a minor one.

## BondNFT.sol

The contract makes use of index-based in-memory struct creation ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L69-L81)) with comments for each value instead of using the key-value declaration format. We advise this to be done so increasing the legibility of the codebase (i.e. for `struct Foo { uint256 x; uint256 y; }` we have `Foo({ x: 5, y: 3 })` in the key-value format).

Two statements in the code use a ternary operator to yield a `bool` result ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L238), [#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L252)) when the actual conditional evaluated can be used directly.

The labelling of the `safeTransferMany` function is **misleading** as it does not actually invoke the "safe" counterpart of the EIP-721 standard ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L282-L288)) and instead performs a `_transfer` operation unlike `safeTransferFromMany` which properly invokes `safeTransferFrom`, the latter of which is re-entrant. We advise the function to be renamed to `transferMany` conforming to the same coding style the code already has without being misleading.

The `extendLock` system is susceptible to a race condition if the `Lock` contract is integrated by non-EOA parties as a lock extension renders the NFT immovable ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L332)). This can cause a user to detect a sale / transfer operation and invoke `extendLock` to prevent the action. While this is not actively exploitable due to `extendLock` of `Lock` requiring ownership of the NFT, if the owner is a smart contract which multiple users can interact with this can be come an issue. 

The `extendLock` system "refreshes" a lock rather than "extending" it as its `mintTime` and `mintEpoch` are reset ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L114), [#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L120-L121)). This is most likely undesirable behaviour as an extension of a 7 week lock towards its end by one day should not lead to an actual increase of 8 days. We strongly advise this to be revised as it would also indirectly alleviate the issue described above.

## GovNFT.sol

The code should split long numeric literals (i.e. `10000`) ([#1}(https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L16), [#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L17)) using the special-purpose underscore (`_`) separator (i.e. `10_000`) to increase their legibility similarly to L144.

The `_mint` function uses the `MAX` contract literal while the `_bridgeMint` function uses its numeric literal equivalent ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L66)) for the ID validations. We advise the `MAX` literal to be used for `_bridgeMint` as well.

The `_bridgeMint` function is invoke-able by its owner ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L65) which should be prohibited as accidental invocation can corrupt the NFT token ID state of the system (i.e. minting a token that has not yet been set in circulation within the contract or was previously in circulation and was consequently burned).

The `_bridgeMint` of `GovNFTBridged` (out-of-scope) contains a different check ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFTBridged.sol#L50)) for token ID validity than the `_bridgeMint` of `GovNFT` ([#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L66)) which should be re-evaluated as correct.

## PairsContract.sol

Similarly to the `TradingLibrary`, a multitude of unsafe casting operations from `uint256` to `int256` can be observed ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L48), [#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L52), [#3](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L55), [#4](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L59), [#5](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L62), [#6](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L102), [#7](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L104), [#8](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L107), [#9](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L109), [#10](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L115), [#11](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L117), [#12](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Position.sol#L120)) that can underflow for the same reasons. Once again, we advise the usage of a safe-wrapper library that performs the casting operations safely by applying upper-bound checking with the `type(int256).max` literal.

## NFTSale.sol (Out-of-Scope)

While this contract is out-of-scope, an issue exists that should be noted in its `buy` method. As the price can be arbitrarily set by the owner of the contract, an on-chain race condition may manifest (either by accident or maliciously by a compromised owner account) whereby the price is changed after a user has submitted their transaction purchasing the asset ([#1](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/NFTSale.sol#L32-L34), [#2](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/NFTSale.sol#L40-L52)). This can be alleviated by either setting the price once or by implementing an additional argument to `buy` which acts as a "slippage" value similarly to exchanges whereby a minimum of NFT assets the user specifies are purchased with the specified amount of tokens.


